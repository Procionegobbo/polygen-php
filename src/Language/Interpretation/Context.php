<?php

namespace Polygen\Language\Interpretation;

use Polygen\Grammar\Assignment;
use Polygen\Grammar\Interfaces\DeclarationInterface;
use Polygen\Language\ContextInterface;
use Polygen\Language\Document;
use Polygen\Language\Token\Token;
use Savvot\Random\MtRand;
use Webmozart\Assert\Assert;

/**
 * Object representing the current status during Polygen sentence generation.
 */
class Context implements ContextInterface
{
    /**
     * The symbol from which generation should start.
     * @var string
     */
    private $startSymbol;

    /**
     * The token sequences generated by all assigned assignments, keyed by assignment name.
     * @var Token[][]
     */
    private $assignedAssignments;

    /**
     * @var MtRand
     */
    private $randomNumberGenerator;
    /**
     * @var \Polygen\Grammar\Interfaces\DeclarationInterface[]
     */
    private $declarationsContext;

    /**
     * @param \Polygen\Language\Context $declarations
     * @param string $startSymbol The declaration from which the production should start.
     */
    public function __construct($startSymbol = Document::START, $seed = null)
    {
        $this->declarationsContext = new \Polygen\Language\Context();
        $this->randomNumberGenerator = new MtRand($seed);
        $this->startSymbol = $startSymbol;
    }

    /**
     * @param Token[] $tokens
     */
    public function assign(Assignment $assignment, array $tokens)
    {
        $clone = clone $this;
        $this->assignedAssignments[$assignment->getName()] = $tokens;
        return $clone;
    }

    /**
     * Checks whether an assignment has already been processed and its generated value has been stored in the context.
     *
     * @return bool
     */
    public function isAssigned(Assignment $assignment)
    {
        return array_key_exists($assignment->getName(), $this->assignedAssignments);
    }

    /**
     * Returns the token sequence for an already processed assignment.
     *
     * @return Token[]
     */
    public function getAssigned(Assignment $assignment)
    {
        Assert::keyExists(
            $this->assignedAssignments,
            $assignment->getName(),
            "Undefined assignment: {$assignment->getName()}."
        );
        return $this->assignedAssignments[$assignment->getName()];
    }

    /**
     * @param int $min
     * @param int $max
     * @return int
     */
    public function getRandomNumber($min, $max)
    {
        return $this->randomNumberGenerator->random($min, $max);
    }

    /**
     * Returns the start symbol from which generation should take place.
     *
     * @return string
     */
    public function getStartSymbol()
    {
        return $this->startSymbol;
    }

    /**
     * @param string $declaration
     * @return bool
     */
    public function isDeclared($declaration)
    {
        return $this->declarationsContext->isDeclared($declaration);
    }

    /**
     * @param DeclarationInterface[] $declarations
     * @return \Polygen\Language\Interpretation\Context
     */
    public function mergeDeclarations(array $declarations)
    {
        $clone = clone $this;
        $clone->declarationsContext = $this->declarationsContext->mergeDeclarations($declarations);
        return $clone;
    }

    /**
     * @param string $declarationName
     * @return \Polygen\Grammar\Interfaces\DeclarationInterface|\Polygen\Grammar\Interfaces\Node
     */
    public function getDeclaration($declarationName)
    {
        return $this->declarationsContext->getDeclaration($declarationName);
    }

    /**
     * @return bool
     */
    public function isEmpty()
    {
        return $this->declarationsContext->isEmpty();
    }
}

<?php

namespace Polygen\Language\Interpretation;

use Polygen\Document;
use Polygen\Grammar\Assignment;
use Polygen\Grammar\Interfaces\DeclarationInterface;
use Polygen\Language\Token\Token;
use Webmozart\Assert\Assert;

/**
 * Object representing the current status during Polygen sentence generation.
 */
class Context extends \Polygen\Language\Context
{
    /**
     * The symbol from which generation should start.
     * @var string
     */
    private $startSymbol;

    /**
     * The token sequences generated by all assigned assignments, keyed by assignment name.
     * @var Token[][]
     */
    private $assignedAssignments;

    /**
     * @param DeclarationInterface[] $declarations
     * @param string $startSymbol
     */
    public function __construct(array $declarations = [], $startSymbol = Document::START)
    {
        parent::__construct($declarations);
        $this->startSymbol = $startSymbol;
    }

    /**
     * @param Token[] $tokens
     */
    public function assign(Assignment $assignment, array $tokens)
    {
        $clone = clone $this;
        $this->assignedAssignments[$assignment->getName()] = $tokens;
        return $clone;
    }

    /**
     * Checks whether an assignment has already been processed and its generated value has been stored in the context.
     *
     * @return bool
     */
    public function isAssigned(Assignment $assignment)
    {
        return array_key_exists($assignment->getName(), $this->assignedAssignments);
    }

    /**
     * Returns the token sequence for an already processed assignment.
     *
     * @return Token[]
     */
    public function getAssigned(Assignment $assignment)
    {
        Assert::keyExists(
            $this->assignedAssignments,
            $assignment->getName(),
            "Undefined assignment: {$assignment->getName()}."
        );
        return $this->assignedAssignments[$assignment->getName()];
    }

    /**
     * @param int $min
     * @param int $max
     * @return int
     */
    public function getRandomNumber($min, $max)
    {
        // Currently an alias of rand(), but thought as a method to allow for seedable and swappable random number
        // generators, as seeding the built-in RNG would result in seeding it for the whole execution time (request, if
        // ran from web) which is clearly not a good idea.
        return rand($min, $max);
    }

    /**
     * Returns the start symbol from which generation should take place.
     *
     * @return string
     */
    public function getStartSymbol()
    {
        return $this->startSymbol;
    }
}
